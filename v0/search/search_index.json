{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contribute/","title":"Contribute to the XCM SDK","text":""},{"location":"contribute/#get-started","title":"Get Started","text":"<p>To contribute to the XCM SDK, you'll first need to clone the GitHub repository:</p> <pre><code>git clone git@github.com:moonbeam-foundation/xcm-sdk.git\n</code></pre> <p>Then, install dependencies:</p> <pre><code>npm install\n</code></pre>"},{"location":"contribute/#add-an-asset","title":"Add an Asset","text":"<p>The first step in adding support for a new asset is to define the asset in the assets configuration file. At this stage, assets are not bound to any chain, you are only creating a representation of the asset.</p> <p>Follow these steps:</p> <ol> <li>Open the <code>xcm-sdk/packages/config/src/assets.ts</code> file</li> <li>Create a new variable for your asset. You'll need to create an <code>Asset</code> object, providing the <code>key</code> and <code>originSymbol</code> of the asset</li> </ol> <pre><code>export const INSERT_ASSET_NAME = new Asset({\n  key: 'INSERT_KEY',\n  originSymbol: 'INSERT_ORIGIN_SYMBOL',\n});\n</code></pre> <p>For example, this is the configuration used for USDT:</p> <pre><code>export const usdt = new Asset({\n  key: 'usdt',\n  originSymbol: 'USDT',\n});\n</code></pre> <ol> <li>Add your asset to the <code>assetsList</code> array at the end of the file</li> </ol> <p>Note</p> <p>Assets are listed in alphabetical order. Please make sure you follow this order when adding new assets.</p>"},{"location":"contribute/#add-a-chain","title":"Add a Chain","text":"<p>The next step to support an asset integration is to add chain information for the chains in which your asset can be sent to and from to the chains configuration file.</p> <p>To add a chain, take the following steps:</p> <ol> <li>Open the <code>xcm-sdk/packages/config/src/chains.ts</code> file</li> <li>Add your asset to the list of imported assets from the assets configuration file (<code>./assets.ts</code>)</li> <li> <p>Create a new variable for each chain if an entry doesn't already exist. You'll need to create a <code>Chain</code> object, providing metadata related to the chain</p> ParachainEVM Parachain <pre><code>new Parachain({\n  assetsData: [], // Optional - In the next step, you'll add assets here\n  ecosystem: Ecosystem.INSERT_ECOSYSTEM_TYPE, // Optional\n  genesisHash: 'INSERT_GENESIS_HASH',\n  isTestChain: INSERT_BOOLEAN, // Optional\n  key: 'INSERT_KEY',\n  name: 'INSERT_NAME',\n  parachainId: INSERT_PARACHAIN_ID,\n  ss58Format: INSERT_SS58_FORMAT,\n  usesChainDecimals: INSERT_BOOLEAN, // Optional\n  ws: 'INSERT_WSS_ENDPOINT',\n})\n</code></pre> <pre><code>new EvmParachain({\n  assetsData: [], // Optional - In the next step, you'll add assets here\n  ecosystem: Ecosystem.INSERT_ECOSYSTEM_TYPE, // Optional\n  genesisHash: 'INSERT_GENESIS_HASH',\n  id: INSERT_EVM_CHAIN_ID,\n  isTestChain: INSERT_BOOLEAN, // Optional\n  key: 'INSERT_KEY',\n  name: 'INSERT_NAME',\n  nativeCurrency: {\n    decimals: INSERT_ASSET_DECIMALS,\n    name: 'INSERT_ASSET_NAME',\n    symbol: 'INSERT_ASSET_SYMBOL',\n  },\n  parachainId: INSERT_PARACHAIN_ID,\n  rpc: 'INSERT_RPC_ENDPOINT',\n  ss58Format: INSERT_SS58_FORMAT,\n  usesChainDecimals: INSERT_BOOLEAN, // Optional\n  ws: 'INSERT_WSS_ENDPOINT',\n})\n</code></pre> <p>For example, this is the configuration for the Polkadot Asset Hub:</p> <pre><code>export const polkadotAssetHub = new Parachain({\n  assetsData: [ ... ],\n  ecosystem: Ecosystem.Polkadot,\n  genesisHash:\n    '0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f',\n  key: 'Polkadot-asset-hub',\n  name: 'Polkadot Asset Hub',\n  parachainId: 1000,\n  ss58Format: 42,\n  ws: 'wss://polkadot-asset-hub-rpc.polkadot.io',\n});\n</code></pre> </li> <li> <p>Add the newly created chain to the <code>chainsList</code> array at the end of the file</p> </li> </ol> <p>Note</p> <p>Chains are listed in alphabetical order. Please make sure you follow this order when adding new chains.</p> <p>Now that you've added the chain, you can continue to the next section to add the assets that this chain supports.</p>"},{"location":"contribute/#configure-a-chains-assets","title":"Configure a Chain's Assets","text":"<p>To designate a chain as a destination or source chain for an asset, you must specify the asset within the <code>assetsData</code> array of the chain's configuration. This array outlines the supported assets on the chain, and the asset information within it determines how the asset is identified or targeted on that specific chain. For example, when adding a chain's native asset, you'll need to define how the chain sees its own asset, and when adding the asset to a destination chain, you'll need to define how the destination chain sees the asset.</p> <p>To enable an asset to move between chains, follow these steps to configure the source and destination chains of an asset:</p> <ol> <li>In the <code>assetsData</code> array of the source chain, you'll need to create a <code>Parachain</code> or <code>EvmParachain</code> (for EVM-compatible chains) object for the asset, specifying how the asset is seen on that chain</li> </ol> <pre><code>{\n  asset: INSERT_IMPORTED_ASSET, // The asset created in the previous section\n  balanceId: INSERT_CHAIN_ASSET_ID, // (Optional) The balance ID of the asset\n  decimals: INSERT_ASSET_DECIMALS // (Optional) The decimals of the asset\n  id: INSERT_CHAIN_ASSET_ID, // (Optional) Location of the asset on the chain. Different for every chain\n  metadata: INSERT_CHAIN_ASSET_ID // (Optional) The metadata of the asset\n  min: INSERT_MIN // (Optional) The minimum amount of the asset that is required to be left in the account\n  minId: INSERT_CHAIN_ASSET_ID // (Optional) The minimum ID of the asset\n  palletInstance: INSERT_PALLET_INSTANCE // (Optional) The pallet instance the asset belongs to\n}\n</code></pre> <p>For example, this is the configuration for USDT on the Polkadot Asset Hub:</p> <pre><code>export const polkadotAssetHub = new Parachain({\n  assetsData: [\n    {\n      asset: usdt,\n      id: 1984, // The asset ID for USDT\n      palletInstance: 50, // The index of the Assets pallet (where USDT lives)\n    },\n  ],\n  ...\n});\n</code></pre> <ol> <li>In the destination chain's <code>assetsData</code> array, create a <code>Parachain</code> or <code>EvmParachain</code> (for EVM-compatible chains) object that defines the asset as seen on the destination chain. This will be different than the source chain's configurations, as every chain manages assets differently</li> </ol> <p>For example, to add support for USDT on Moonbeam, Moonbeam's chain configuration needs to include the configuration for USDT:</p> <pre><code>export const moonbeam = new EvmParachain({\n  assetsData: [\n    ...\n    {\n      asset: usdt,\n      id: '311091173110107856861649819128533077277', // The asset ID of USDT on Moonbeam\n    },\n    ...\n  ]\n  ...\n});\n</code></pre> <p>The integration isn't complete yet; you'll need to define the methods used for cross-chain transfers for any new chains added. This will be covered in the following section.</p>"},{"location":"contribute/#configure-a-chains-extrinsics","title":"Configure a Chain's Extrinsics","text":"<p>In this step, you have to create or update the configuration files of the chains between which you can transfer the asset. These files define the asset being transferred, the destination chain, information associated to fees, and builder functions. These builders define the pallets and methods necessary to achieve the specific goals of each type. They are as follows:</p> <ul> <li>Minimum Asset Builder - builds a query to retrieve the minimum amount of an asset required to be left in an account</li> <li>Balance Builder - builds a query to retrieve the balance of an asset for a given account</li> <li>Contract Builder - builds the contract call for the cross-chain transfer. This is specific to EVM chains that use contracts to interact with Substrate pallets for cross-chain transfers, such as Moonbeam's X-Tokens precompiled contract</li> <li>Extrinsic Builder - builds the extrinsic for the cross-chain transfer</li> <li>Fee Builder - builds the query to retrieve the fee for the execution of the cross-chain transfer</li> </ul> <p>You will need to know which pallet and method each chain is using for its XCM transactions and for fetching asset balances, and make sure that said pallets and methods are already available in the xcm-builder package.</p> <p>If they aren't available, feel free to open a PR or submit an issue on GitHub.</p> <p>Assuming that all of the required pallets and methods are already supported, you can create the configuration file for the source chain:</p> <ol> <li>In the <code>xcm-sdk/packages/config/src/configs/</code> directory, add a TypeScript file for the new chain</li> <li>Use the following snippet as a starting point for adding the chain configuration:</li> </ol> <pre><code>import { INSERT_REQUIRED_BUILDERS } from '@moonbeam-network/xcm-builder';\nimport { INSERT_REQUIRED_ASSETS } from '../assets';\nimport { INSERT_REQUIRED_CHAINS } from '../chains';\nimport { AssetConfig } from '../types/AssetConfig';\nimport { ChainConfig } from '../types/ChainConfig';\n\n// The chain config name should be formatted as: 'chainName' + 'Config'\nexport const INSERT_CHAIN_CONFIG_NAME = new ChainConfig({\n  assets: [], // In the next step, you'll add asset configs here\n  chain: INSERT_CHAIN, // The source chain\n});\n</code></pre> <ol> <li>As seen in the above example, an <code>assets</code> array contains the chain's asset configurations. The asset configuration defines the asset being transferred, the destination chain, information associated with fees, and the builder functions. The builder functions must be used to build the queries or calls as if they were being executed from this chain.</li> </ol> <p>You'll need to create an Asset Config object for each asset, for example:</p> <pre><code>new AssetConfig({\n  asset: INSERT_ASSET,\n  balance: INSERT_BALANCE_BUILDER,\n  contract: INSERT_CONTRACT_BUILDER, // Optional\n  destination: INSERT_DESTINATION_CHAIN,\n  destinationFee: {\n    amount: INSERT_FEE_BUILDER,\n    asset: INSERT_ASSET,\n    balance: INSERT_BALANCE_BUILDER,\n  },\n  extrinsic: INSERT_EXTRINSIC_BUILDER, // Optional\n  fee: {\n    // Optional\n    asset: INSERT_ASSET,\n    balance: INSERT_BALANCE_BUILDER,\n    xcmDeliveryFeeAmount: INSERT_FEE_AMOUNT, // Optional\n  },\n  min: INSERT_MIN_ASSET_BUILDER, // Optional\n});\n</code></pre> <ol> <li>Add the newly created chain configurations to the <code>chainsConfigList</code> in the <code>xcm-sdk/blob/main/packages/config/src/configs/index.ts</code> file</li> </ol> <p>Note</p> <p>Chain configurations are listed in alphabetical order. Please follow this order when adding new chain configurations.</p> <p>For example, to add support to transfer USDT from the Polkadot Asset Hub to Moonbeam, the Polkadot Asset Hub configuration file is as follows:</p> <pre><code>import {\n  AssetMinBuilder,\n  BalanceBuilder,\n  ExtrinsicBuilder,\n  FeeBuilder,\n} from '@moonbeam-network/xcm-builder';\nimport { usdt } from '../assets';\nimport { moonbeam, polkadotAssetHub } from '../chains';\nimport { AssetConfig } from '../types/AssetConfig';\nimport { ChainConfig } from '../types/ChainConfig';\n\nconst xcmDeliveryFeeAmount = 0.036;\n\nexport const polkadotAssetHubConfig = new ChainConfig({\n  assets: [\n    ...new AssetConfig({\n      asset: usdt,\n      balance: BalanceBuilder().substrate().assets().account(),\n      destination: moonbeam,\n      destinationFee: {\n        amount: FeeBuilder().assetManager().assetTypeUnitsPerSecond(),\n        asset: usdt,\n        balance: BalanceBuilder().substrate().assets().account(),\n      },\n      extrinsic: ExtrinsicBuilder()\n        .polkadotXcm()\n        .limitedReserveTransferAssets()\n        .X2(),\n      fee: {\n        asset: dot,\n        balance: BalanceBuilder().substrate().system().account(),\n        xcmDeliveryFeeAmount,\n      },\n      min: AssetMinBuilder().assets().asset(),\n    }),\n  ],\n  chain: polkadotAssetHub,\n});\n</code></pre> <p>You're almost there. With this configuration, you can send the asset one-way from the configured chain to the asset's specified destination chain. To send the asset back to the original source chain, you must update (or create) the specified destination chain's configurations. Considering the above example, the Moonbeam configuration file would need to be updated to transfer USDT from Moonbeam back to the Polkadot Asset Hub.</p> <p>You must take the same steps in the destination chain's configuration file. If a configuration file does not exist, you must create one. Otherwise, update the chain's configuration file to include the asset configuration, as step three outlines.</p> <p>For example, enabling USDT transfers from Moonbeam back to the Polkadot Asset Hub requires the following Moonbeam chain configuration:</p> <pre><code>import { BalanceBuilder, ContractBuilder } from '@moonbeam-network/xcm-builder';\nimport {\n  ...\n  usdt,\n} from '../assets';\nimport {\n  ...\n  polkadotAssetHub,\n} from '../chains';\nimport { AssetConfig } from '../types/AssetConfig';\nimport { ChainConfig } from '../types/ChainConfig';\n\nexport const moonbeamConfig = new ChainConfig({\n  assets: [\n    ...\n    new AssetConfig({\n      asset: usdt,\n      balance: BalanceBuilder().substrate().assets().account(),\n      contract: ContractBuilder().Xtokens().transfer(),\n      destination: polkadotAssetHub,\n      destinationFee: {\n        amount: 0.7,\n        asset: usdt,\n        balance: BalanceBuilder().substrate().assets().account(),\n      },\n      fee: {\n        asset: glmr,\n        balance: BalanceBuilder().substrate().system().account(),\n      },\n    }),\n  ],\n  chain: moonbeam,\n});\n</code></pre> <p>And that's it! You now know how to add new assets and chains and configure the chains that an asset can be sent to and from. To ensure that you've properly set everything up, read on to the next section.</p>"},{"location":"contribute/#test-new-configurations","title":"Test New Configurations","text":"<p>The SDK is configured to work for most parachains in the Polkadot ecosystem. However, any given chain might have a different or particular way of requesting a specific piece of information, for example, if it uses unconventional pallets or different methods for existing pallets.</p> <p>You can use the following queries to ensure that the new configurations have been properly set up.</p> <ul> <li> <p><code>assetRegistry.assetMetadatas</code> - From here, we extract the <code>decimals</code> and the <code>minBalance</code> for   <code>aSEED</code>:</p> <pre><code>{\n  name: aUSD SEED\n  symbol: aSEED\n  decimals: 12\n  minimalBalance: 100,0\n}\n</code></pre> </li> <li> <p><code>assets.metadata</code> - Here, we get the <code>decimals</code> for <code>DOT</code></p> </li> </ul> <pre><code>{\n  deposit: 0;\n  name: xcDOT;\n  symbol: xcDOT;\n  decimals: 10;\n  isFrozen: false;\n}\n</code></pre> <ul> <li><code>balances.existentialDeposit</code> - This is the standard way of querying the existential deposit for most chains</li> </ul> <pre><code>100000000000;\n</code></pre> <p>Most cases are considered already, but for newly integrated chains, this data might be queried by a different pallet or function. You can check if the pallet is supported in the Polkadot Service file.</p>"},{"location":"example-usage/","title":"Using the Moonbeam XCM SDK","text":""},{"location":"example-usage/#introduction","title":"Introduction","text":"<p>The Moonbeam XCM SDK enables developers to easily deposit and withdraw assets to Moonbeam/Moonriver from the relay chain and other parachains in the Polkadot/Kusama ecosystem. With the SDK, you don't need to worry about determining the multilocation of the origin or destination assets or which extrinsics are used on which networks to send XCM transfers. To deposit or withdraw assets, you simply define the asset and origin chain you want to deposit from or withdraw back to, along with the sending account's signer, and the amount to send.</p> <p>The XCM SDK offers simple helper functions like <code>deposit</code> and <code>withdraw</code>, that provide a very simple interface to execute XCM transfers between chains in the Polkadot/Kusama ecosystem. In addition, the XCM config package allows any parachain project to add their information in a standard way, so they can be immediately supported by the XCM SDK.</p> <p>For an overview of the available methods and interfaces in the Moonbeam XCM SDK, please refer to the Reference page.</p> <p>The examples in this guide are shown on Moonbeam, but can be adapted to be used on Moonriver or Moonbase Alpha.</p>"},{"location":"example-usage/#getting-started","title":"Getting Started","text":"<p>To get started with the XCM SDK, you'll first need to install the corresponding NPM package. Next, you'll also need to create signers to be used to sign transactions to transfer assets between Moonbeam and another chain within the Polkadot ecosystem. Lastly, you'll need to initialize the API which will provide you with asset and chain information and the necessary functions to deposit, withdraw, and subscribe to balance information.</p>"},{"location":"example-usage/#installation","title":"Installation","text":"<p>For the purposes of this guide you'll need to install two packages: the XCM SDK package, and the XCM config package.</p> <p>The XCM SDK package will enable you to easily deposit and withdraw assets, and subscribe to balance information for each of the supported assets.</p> <p>The XCM config package will be used to obtain origin asset and chain information for each of the supported assets. The config package also includes native asset and chain information for each of the Moonbeam-based networks, as well as some underlying functions of the SDK.</p> <p>To install the XCM SDK and XCM config packages, you can run the following command:</p> <pre><code>npm install @moonbeam-network/xcm-sdk @moonbeam-network/xcm-config\n</code></pre> <p>You need to have peer dependencies, like Ethers.js and the Polkadot.js API installed.</p> <p>You can install them by running the following command:</p> <pre><code>npm i @polkadot/api-augment @polkadot/types @polkadot/util @polkadot/util-crypto ethers\n</code></pre> <p>Note</p> <p>There is a known issue when using the Moonbeam XCM packages alongside Polkadot.js with Node.js (JavaScript) that will cause package conflict warnings to appear in the console. Using TypeScript is recommended.</p>"},{"location":"example-usage/#creating-signers","title":"Creating Signers","text":"<p>When interacting with the <code>deposit</code> and <code>withdraw</code> functions of the XCM SDK, you'll need to provide an Ethers.js and Polkadot.js signer, which will be used to sign and send the transactions. The Ethers signer is used to sign transactions on Moonbeam, and the Polkadot signer will be used to sign transactions on the origin chain you're depositing assets from.</p> <p>You can pass, for example, a MetaMask signer into Ethers or another compatible wallet. Similarly with Polkadot, you can pass a compatible wallet to the signer using the <code>@polkadot/extension-dapp</code> library.</p> <p>To create a signer for Ethers.js and Polkadot.js, you can refer to the following code snippets. In this example, you can use a Polkadot.js Keyring to sign transactions on the origin chain for deposits. Please note that this approach is not recommended for production applications. Never store your private key or mnemonic in a JavaScript or TypeScript file.</p> MoonbeamMoonriverMoonbase Alpha <pre><code>import { ethers } from 'ethers';\nimport { Keyring } from '@polkadot/api';\n\n// Set up Ethers provider and signer\nconst providerRPC = {\n  moonbeam: {\n    name: 'moonbeam',\n    rpc: '{{ networks.moonbeam.rpc_url }}',\n    chainId: {{ networks.moonbeam.chain_id }}, // {{ networks.moonbeam.hex_chain_id }} in hex,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbeam.rpc, {\n  chainId: providerRPC.moonbeam.chainId,\n  name: providerRPC.moonbeam.name,\n});\nconst ethersSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\n\n// Set up Polkadot keyring\nconst keyring = new Keyring({ type: 'sr25519' });\nconst polkadotKeyring = keyring.addFromUri(mnemonic);\n</code></pre> <pre><code>import { ethers } from 'ethers';\nimport { Keyring } from '@polkadot/api';\n\n// Set up Ethers provider and signer\nconst providerRPC = {\n  moonriver: {\n    name: 'moonriver',\n    rpc: '{{ networks.moonriver.rpc_url }}',\n    chainId: {{ networks.moonriver.chain_id }}, // {{ networks.moonriver.hex_chain_id }} in hex,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonriver.rpc, {\n  chainId: providerRPC.moonriver.chainId,\n  name: providerRPC.moonriver.name,\n});\nconst ethersSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\n\n// Set up Polkadot keyring\nconst keyring = new Keyring({ type: 'sr25519' });\nconst polkadotKeyring = keyring.addFromUri('INSERT_MNEMONIC');\n</code></pre> <pre><code>import { ethers } from 'ethers';\nimport { Keyring } from '@polkadot/api';\n\n// Set up Ethers provider and signer\nconst providerRPC = {\n  moonbase: {\n    name: 'moonbase-alpha',\n    rpc: '{{ networks.moonbase.rpc_url }}',\n    chainId: {{ networks.moonbase.chain_id }}, // {{ networks.moonbase.hex_chain_id }} in hex,\n  },\n};\nconst provider = new ethers.JsonRpcProvider(providerRPC.moonbase.rpc, {\n  chainId: providerRPC.moonbase.chainId,\n  name: providerRPC.moonbase.name,\n});\nconst ethersSigner = new ethers.Wallet('INSERT_PRIVATE_KEY', provider);\n\n// Set up Polkadot keyring\nconst keyring = new Keyring({ type: 'sr25519' });\nconst polkadotKeyring = keyring.addFromUri('INSERT_MNEMONIC');\n</code></pre>"},{"location":"example-usage/#initializing","title":"Initialization","text":"<p>To be able to deposit, withdraw, and subscribe to balance information for all of the supported assets, you'll need to start off by importing the <code>init</code> function from the XCM SDK and call it:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>import { init } from '@moonbeam-network/xcm-sdk';\nconst { moonbeam } = init();\n</code></pre> <pre><code>import { init } from '@moonbeam-network/xcm-sdk';\nconst { moonriver } = init();\n</code></pre> <pre><code>import { init } from '@moonbeam-network/xcm-sdk';\nconst { moonbase } = init();\n</code></pre> <p>If you intend to support a specific wallet, you can pass a signer into the <code>init</code> function right away. Otherwise, you'll be able to pass a signer directly when building the transfer data for a deposit or withdraw. To pass in a signer for Ethers and Polkadot, you can use the following snippet:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>import { init } from '@moonbeam-network/xcm-sdk';\nconst { moonbeam } = init({\n  ethersSigner: 'INSERT_ETHERS_SIGNER',\n  polkadotSigner: 'INSERT_POLKADOT_SIGNER',\n});\n</code></pre> <pre><code>import { init } from '@moonbeam-network/xcm-sdk';\nconst { moonriver } = init({\n  ethersSigner: 'INSERT_ETHERS_SIGNER',\n  polkadotSigner: 'INSERT_POLKADOT_SIGNER',\n});\n</code></pre> <pre><code>import { init } from '@moonbeam-network/xcm-sdk';\nconst { moonbase } = init({\n  ethersSigner: 'INSERT_ETHERS_SIGNER',\n  polkadotSigner: 'INSERT_POLKADOT_SIGNER',\n});\n</code></pre>"},{"location":"example-usage/#using-the-api","title":"Using the SDK Interfaces","text":"<p>The Moonbeam SDK provides an API which includes a series of interfaces to get asset information for each of the supported assets, chain information for the initialized network, and functions to enable deposits, withdrawals, and subscription to balance information.</p> <p>Make sure you have initialized the Moonbeam network you want to interact with first.</p>"},{"location":"example-usage/#symbols","title":"Asset Symbols","text":"<p>An asset symbol refers to the symbol of the asset on the origin chain. For example, <code>GLMR</code> is the native asset on Moonbeam.</p> <p>To get a list of the supported asset symbols for each network, you can access the <code>symbols</code> property:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam.symbols\n</code></pre> <pre><code>moonriver.symbols\n</code></pre> <pre><code>moonbase.symbols\n</code></pre> <p>An example of the data contained in the <code>symbols</code> property is as follows:</p> <pre><code>['ACA', 'ASTR', 'AUSD', 'DOT', 'GLMR', 'IBTC', 'INTR', 'PARA', 'PHA'];\n</code></pre>"},{"location":"example-usage/#assets","title":"Assets","text":"<p>To get a list of the supported assets along with their asset ID, precompiled contract address on Moonbeam, and their origin asset symbols, you can access the <code>assets</code> property:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam.assets\n</code></pre> <pre><code>moonriver.assets\n</code></pre> <pre><code>moonbase.assets\n</code></pre> <p>An example of the data contained in the <code>assets</code> property is as follows:</p> <pre><code>assets: {\n  ACA: {\n    id: '224821240862170613278369189818311486111',\n    erc20Id: '0xffffffffa922fef94566104a6e5a35a4fcddaa9f',\n    originSymbol: 'ACA'\n  },\n  ASTR: {\n    id: '224077081838586484055667086558292981199',\n    erc20Id: '0xffffffffa893ad19e540e172c10d78d4d479b5cf',\n    originSymbol: 'ASTR'\n  },\n  ...\n}\n</code></pre> <p>Where the <code>id</code> refers to the asset ID, the <code>erc20id</code> refers to the asset's precompiled contract address, and the <code>originSymbol</code> refers to the asset's symbol on the origin chain.</p>"},{"location":"example-usage/#native-assets","title":"Moonbeam Native Asset Data","text":"<p>To get information about each of the Moonbeam network's native protocol asset, such as the precompile contract address and the origin symbol, you can access the <code>moonAsset</code> property:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam.moonAsset\n</code></pre> <pre><code>moonriver.moonAsset\n</code></pre> <pre><code>moonbase.moonAsset\n</code></pre> <p>An example of the data contained in the <code>moonAsset</code> property is as follows:</p> <pre><code>moonAsset: {\n  id: '',\n  erc20Id: '{{ networks.moonbeam.precompiles.erc20 }}',\n  originSymbol: 'GLMR',\n  isNative: true\n}\n</code></pre> <p>Where the <code>erc20Id</code> refers to the precompile contract address on Moonbeam, the <code>originSymbol</code> is the symbol for the native asset, and <code>isNative</code> is a boolean indicating whether the asset is a native asset.</p>"},{"location":"example-usage/#native-chain-data","title":"Moonbeam Native Chain Data","text":"<p>To get information about each of the Moonbeam network's chain information including the chain key, name, WSS endpoint, parachain ID, protocol asset symbols, chain ID, and units per second, you can access the <code>moonChain</code> property:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam.moonChain\n</code></pre> <pre><code>moonriver.moonChain\n</code></pre> <pre><code>moonbase.moonChain\n</code></pre> <p>An example of the data contained in the <code>moonChain</code> property is as follows:</p> <pre><code>moonChain: {\n  key: 'Moonbeam',\n  name: 'Moonbeam',\n  ws: 'wss://wss.api.moonbeam.network',\n  parachainId: 2004,\n  decimals: 18,\n  chainId: 1284,\n  unitsPerSecond: 10000000000000000000n\n}\n</code></pre> <p>Here, the units per second refer to units of token (in this case Wei) that is charged per second of execution of the XCM message. You can find more information in the XCM fees page.</p>"},{"location":"example-usage/#using-the-sdk-methods","title":"Using the SDK Methods","text":"<p>The Moonbeam SDK provides an API that includes functions which enable deposits, withdrawals, and subscription to balance information, in addition to a few utility functions.</p> <p>Make sure you have initialized the Moonbeam network you want to interact with first. You'll also need to make sure you've created signers in order to sign and send deposit and withdraw transfer data.</p>"},{"location":"example-usage/#deposit","title":"Deposit","text":"<p>To deposit an asset to Moonbeam from another network, you'll have to first build the transfer data using information from the origin chain before you can send it. You'll need to use a series of deposit methods to build the transfer data.</p> <p>The process for building and sending a deposit transfer data is as follows:</p> <ol> <li>Call the <code>deposit</code> function and pass in the asset symbol or the asset object for the asset to be deposited. This will return a <code>chains</code> array containing the asset's origin network information and a <code>from</code> function which will be used to build the transfer data</li> <li>Call the <code>from</code> function and pass in the chain key or the chain object of the origin network. You can get the chain object from the <code>chains</code> array returned from the <code>deposit</code> function. You can get the chain key one of two ways: by accessing the key property of the chain object (<code>chain.key</code>) or by directly importing <code>ChainKey</code> from the XCM config package (as seen in the example below)</li> <li>Call <code>get</code> and pass in the address of the account on Moonbeam you want to deposit the funds to and a signer or Polkadot address depending on how your code is configured, please refer to the Get section for more information. For the purposes of this guide, you'll need to pass in a Polkadot.js <code>Keyring</code> to sign the transaction as created in the Creating Signers section. The <code>get</code> function returns a <code>send</code> function which already contains all the necessary info to perform the deposit, and it is used in the next step. In addition, other elements such as information about the origin chain asset and the <code>xc</code> representation of the asset on Moonbeam are returned and might be important for logging purposes</li> <li>The <code>send</code> function is used to send the built deposit transfer data along with the amount to send. You can optionally provide a callback function to handle the extrinsic events</li> </ol> <p>To obtain some of the data required to build the deposit transfer data, such as the asset symbol and chain key of the origin network, you can import <code>AssetSymbol</code> and <code>ChainKey</code> from the <code>@moonbeam-network/xcm-config</code> package.</p> <p>An example of the steps described above to deposit DOT from the Polkadot relay chain to xcDOT on Moonbeam is as follows:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\nasync function deposit() {\n  const dot = AssetSymbol.DOT;\n  const polkadot = ChainKey.Polkadot;\n\n  const { chains, from } = moonbeam.deposit(dot);\n\n  console.log(\n    `\\nYou can deposit ${dot} from these chains: `,\n    chains.map((chain) =&gt; chain.name),\n  );\n\n  const { asset, sourceBalance, source, min, send } = await from(polkadot).get(\n    'INSERT_MOONBEAM_ADDRESS',\n    polkadotKeyring, // See the Get section for other accepted arguments\n  );\n\n  console.log(\n    `Your ${asset.originSymbol} balance in ${source.name}: ${toDecimal(\n      sourceBalance,\n      asset.decimals,\n    ).toFixed()}. Minimum transferable amount is: ${toDecimal(\n      min,\n      asset.decimals,\n    ).toFixed()}`,\n  );\n\n  await send('INSERT_AMOUNT', (event) =&gt; console.log(event));\n}\n\ndeposit();\n</code></pre>"},{"location":"example-usage/#chains-deposit","title":"Chains","text":"<p>As previously mentioned, the <code>deposit</code> function returns a <code>chains</code> array and a <code>from</code> function. The <code>chains</code> array corresponds to the chains you can deposit the given asset from (for the asset that was initially passed into the <code>deposit</code> function). An example of the <code>chains</code> array is as follows:</p> <pre><code>chains: [\n  {\n    key: 'Polkadot',\n    name: 'Polkadot',\n    ws: 'wss://rpc.polkadot.io',\n    weight: 1000000000,\n    parachainId: 0,\n  },\n];\n</code></pre>"},{"location":"example-usage/#from","title":"From","text":"<p>The <code>from</code> function requires a chain key to be passed into it for the origin chain in which the assets are sent from and returns a <code>get</code> function.</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\n...\n\nconst dot = AssetSymbol.DOT;\nconst polkadot = ChainKey.Polkadot;\n\nconst { from } = moonbeam.deposit(dot);\nfrom(polkadot);\n</code></pre>"},{"location":"example-usage/#get-deposit","title":"Get","text":"<p>The <code>get</code> function requires that you pass in the receiving account on Moonbeam and a Polkadot signer or the sending account on Polkadot depending on how you set up your Polkadot signer, and it gets the data required for the deposit.</p> <p>If you have a Polkadot compatible signer, you can pass the signer into the <code>init</code> function, then in the <code>get</code> function you can pass the Polkadot address for the second argument:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\n...\n\nconst dot = AssetSymbol.DOT;\nconst polkadot = ChainKey.Polkadot;\n\nconst { from } = moonbeam.deposit(dot);\nconst response = await from(polkadot).get(\n  'INSERT_MOONBEAM_ADDRESS',\n  'INSERT_POLKADOT_ADDRESS',\n);\n</code></pre> <p>If you have a Polkadot compatible signer but haven't passed it into the <code>init</code> function, then in the <code>get</code> function you can pass in the Polkadot address for the second argument and the Polkadot signer for the third argument:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\n...\n\nconst dot = AssetSymbol.DOT;\nconst polkadot = ChainKey.Polkadot;\n\nconst { from } = moonbeam.deposit(dot);\nconst response = await from(polkadot).get(\n  'INSERT_MOONBEAM_ADDRESS',\n  'INSERT_POLKADOT_ADDRESS',\n  { polkadotSigner },\n);\n</code></pre> <p>If you have a Polkadot Keyring pair, as originally was set up in the Initialization section, you'll pass in the <code>polkadotKeyring</code> as the second parameter:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\n...\n\nconst dot = AssetSymbol.DOT;\nconst polkadot = ChainKey.Polkadot;\n\nconst { from } = moonbeam.deposit(dot);\nconst response = await from(polkadot).get(\n  'INSERT_MOONBEAM_ADDRESS',\n  polkadotKeyring,\n);\n</code></pre> <p>An example of the response for calling <code>get</code> to send DOT from Polkadot to Moonbeam is as follows:</p> <pre><code>{\n  asset: {\n    id: '42259045809535163221576417993425387648',\n    erc20Id: '0xffffffff1fcacbd218edc0eba20fc2308c778080',\n    originSymbol: 'DOT',\n    decimals: 10\n  },\n  existentialDeposit: 10000000000n,\n  min: 33068783n,\n  moonChainFee: {\n    amount: 33068783n,\n    decimals: 10,\n    symbol: 'DOT'\n  },\n  native: {\n    id: '42259045809535163221576417993425387648',\n    erc20Id: '0xffffffff1fcacbd218edc0eba20fc2308c778080',\n    originSymbol: 'DOT',\n    decimals: 10\n  },\n  origin: {\n    key: 'Polkadot',\n    name: 'Polkadot',\n    ws: 'wss://rpc.polkadot.io',\n    weight: 1000000000,\n    parachainId: 0\n  },\n  source: {\n    key: 'Polkadot',\n    name: 'Polkadot',\n    ws: 'wss://rpc.polkadot.io',\n    weight: 1000000000,\n    parachainId: 0\n  },\n  sourceBalance: 0n,\n  sourceFeeBalance: undefined,\n  sourceMinBalance: 0n,\n  getFee: [AsyncFunction: getFee],\n  send: [AsyncFunction: send]\n}\n</code></pre> <p>Where the returned values are as follows:</p> Value Description <code>asset</code> the asset to be transferred <code>existentialDeposit</code> the existential deposit, or the minimum amount an address must  hold to be considered active if one exists, otherwise <code>0n</code> is returned <code>min</code> the minimum transferrable amount <code>moonChainFee</code> the asset and amount that is needed to pay for Moonbeam's XCM fees.  If different from the <code>asset</code> to be transferred, the fee will be sent in this  asset in addition to the <code>asset</code> to be transferred (as of v0.4.0) <code>native</code> the native asset of the source chain <code>origin</code> the chain information for where the asset being transferred natively originates from <code>source</code> the chain information for where the asset being transferred is sent from <code>sourceBalance</code> the balance of the asset being transferred on the source chain <code>sourceFeeBalance</code> the balance in the source chain's native asset to pay a fee for the asset  to be transferred if applicable, otherwise <code>undefined</code> is returned <code>sourceMinBalance</code> the minimum balance of the asset being transferred on the source chain <code>getFee</code> a function that estimates the fees for withdrawing a given amount <code>send</code> a function that sends the deposit transfer data"},{"location":"example-usage/#send-deposit","title":"Send","text":"<p>When calling <code>send</code>, you will actually send the deposit transfer data that has been built using the <code>deposit</code>, <code>from</code>, and <code>get</code> functions. You simply have to pass in a specified amount to send and an optional callback for handling the extrinsic event. For example, entering <code>10000000000n</code> will send <code>1</code> DOT from Polkadot to Moonbeam, as DOT has 10 decimals.</p> <p>You can refer back to the example in the Deposit section to see how the <code>send</code> function is used.</p>"},{"location":"example-usage/#get-fee-deposit","title":"Get Fee","text":"<p>The <code>getFee</code> function estimates the fees for transferring a given amount of the asset specified in the <code>deposit</code> function. An example of getting the fee in Polkadot for transferring DOT to Moonbeam is as follows:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\nimport { init } from '@moonbeam-network/xcm-sdk';\nimport { toDecimal } from '@moonbeam-network/xcm-utils';\n\n// ...\n\nasync function getDepositFee() {\n  const dot = AssetSymbol.DOT;\n  const polkadot = ChainKey.Polkadot;\n\n  const { from } = moonbeam.deposit(dot);\n  const { asset, getFee } = await from(polkadot).get(\n    'INSERT_MOONBEAM_ADDRESS',\n    polkadotKeyring, // See the Get section for other accepted arguments\n  );\n\n  const fee = await getFee('INSERT_AMOUNT');\n  console.log(\n    `Fee to deposit is estimated to be: ${toDecimal(\n      fee,\n      asset.decimals,\n    ).toFixed()} ${dot}`,\n  );\n}\n\ngetDepositFee();\n</code></pre>"},{"location":"example-usage/#withdraw","title":"Withdraw","text":"<p>To withdraw an asset from Moonbeam to send back to the origin network, you'll have to first build the transfer data using information from the origin chain before you can send it. To do so, you'll take the following steps:</p> <ol> <li>Call the <code>withdraw</code> function and pass in the asset symbol or the asset object. This will return a <code>chains</code> array containing the asset's origin network information and a <code>to</code> function which will be used to build the transfer data</li> <li>Call the <code>to</code> function and pass in the chain key of the origin network. You can get the chain object from the <code>chains</code> array returned from the <code>withdraw</code> function. You can get the chain key one of two ways: by accessing the key property of the chain object (<code>chain.key</code>) or by directly importing <code>ChainKey</code> from the XCM config package (as seen in the example below)</li> <li>Call <code>get</code> and pass in the address of the account on the origin network you want to withdraw the funds from and pass in the Ethers signer if you haven't already done so during intialization. This will return information about the origin (destination) chain asset, the <code>xc</code> representation of the asset on Moonbeam. This will return a <code>send</code> function which already contains all the necessary info to perform the withdrawal, and it is used in the next step. In addition, other elements, such as information about the asset, are returned and might be important for logging purposes</li> <li>The <code>send</code> function is used to send the built withdraw transfer data along with the amount to send. You can optionally provide a callback function to handle the extrinsic events</li> </ol> <p>To obtain some of the data required to build the withdraw transfer data, such as the asset symbol and chain key of the origin network, you can import <code>AssetSymbol</code> and <code>ChainKey</code> from the <code>@moonbeam-network/xcm-config</code> package.</p> <p>An example of the steps described above to withdraw xcDOT from Moonbeam to send back to DOT on Polkadot is as follows:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\nasync function withdraw() {\n  const dot = AssetSymbol.DOT;\n  const polkadot = ChainKey.Polkadot;\n\n  const { chains, to } = moonbeam.withdraw(dot);\n\n  console.log(\n    `\\nYou can withdraw ${dot} to these chains: `,\n    chains.map((chain) =&gt; chain.name),\n  );\n\n  const { asset, destination, destinationBalance, min, send } = await to(\n    polkadot,\n  ).get('INSERT_POLKADOT_ADDRESS', {\n    ethersSigner: signer, // Only required if you didn't pass the signer in on initialization\n  });\n\n  console.log(\n    `Your ${asset.originSymbol} balance in ${destination.name}: ${toDecimal(\n      destinationBalance,\n      asset.decimals,\n    ).toFixed()}. Minimum transferable amount is: ${toDecimal(\n      min,\n      asset.decimals,\n    ).toFixed()}`,\n  );\n\n  await send('INSERT_AMOUNT', (event) =&gt; console.log(event));\n}\n\nwithdraw();\n</code></pre>"},{"location":"example-usage/#chains-withdraw","title":"Chains","text":"<p>As previously mentioned, the <code>withdraw</code> function returns a <code>chains</code> array and a <code>to</code> function. The <code>chains</code> array corresponds to the chains you can withdraw the given asset from (for the asset that was initially passed into the <code>withdraw</code> function). An example of the <code>chains</code> array is as follows:</p> <pre><code>chains: [\n  {\n    key: 'Polkadot',\n    name: 'Polkadot',\n    ws: 'wss://rpc.polkadot.io',\n    weight: 1000000000,\n    parachainId: 0,\n  },\n];\n</code></pre>"},{"location":"example-usage/#to","title":"To","text":"<p>The <code>to</code> function requires a chain key to be passed into it for the origin chain in which the assets are being withdrawn back to and returns a <code>get</code> function.</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\n...\n\nconst dot = AssetSymbol.DOT;\nconst polkadot = ChainKey.Polkadot;\n\nconst { to } = moonbeam.withdraw(dot);\n\nto(polkadot);\n</code></pre>"},{"location":"example-usage/#get-withdraw","title":"Get","text":"<p>The <code>get</code> function requires that you pass in the receiving account on the destination chain and the Ethers signer for the sending account on Moonbeam, and it gets the data required for the withdraw.</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\n\n...\n\nconst dot = AssetSymbol.DOT;\nconst polkadot = ChainKey.Polkadot;\n\nconst { to } = moonbeam.deposit(dot);\nconst response =  await to(\n    polkadot,\n  ).get('INSERT_POLKADOT_ADDRESS',\n  { ethersSigner: signer } // Only required if you didn't pass the signer in on initialization\n)\n</code></pre> <p>An example of the response for calling <code>get</code> to send xcDOT from Moonbeam back to DOT on Polkadot is as follows:</p> <pre><code>{\n  asset: {\n    id: '42259045809535163221576417993425387648',\n    erc20Id: '0xffffffff1fcacbd218edc0eba20fc2308c778080',\n    originSymbol: 'DOT',\n    decimals: 10\n  },\n  destination: {\n    key: 'Polkadot',\n    name: 'Polkadot',\n    ws: 'wss://rpc.polkadot.io',\n    weight: 1000000000,\n    parachainId: 0\n  },\n  destinationBalance: 0n,\n  destinationFee: 520000000n,\n  existentialDeposit: 10000000000n,\n  min: 10520000000n,\n  minXcmFeeAsset: {\n    amount: 0n,\n    decimals: 10,\n    symbol: \"DOT\",\n  },\n  native: {\n    id: '42259045809535163221576417993425387648',\n    erc20Id: '0xffffffff1fcacbd218edc0eba20fc2308c778080',\n    originSymbol: 'DOT',\n    decimals: 10\n  },\n  origin: {\n    key: 'Polkadot',\n    name: 'Polkadot',\n    ws: 'wss://rpc.polkadot.io',\n    weight: 1000000000,\n    parachainId: 0\n  },\n  originXcmFeeAssetBalance: undefined,\n  getFee: [AsyncFunction: getFee],\n  send: [AsyncFunction: send]\n}\n</code></pre> <p>Where the returned values are as follows:</p> Value Description <code>asset</code> the asset to be transferred <code>destination</code> the chain information for where the asset is being transferred to <code>destinationBalance</code> the balance of the asset being transferred on the destination chain <code>destinationFee</code> the fee for the asset to be transferred on the destination chain <code>existentialDeposit</code> the existential deposit, or the minimum amount an address must  hold to be considered active if one exists, otherwise <code>0n</code> is returned <code>min</code> the minimum transferable amount of the asset being transferred <code>minXcmFeeAsset</code> the minimum transferable amount of the asset that needs to be sent along to pay for the fees <code>native</code> the native asset of the source chain <code>origin</code> the chain information for where the asset being transferred natively originates from <code>originXcmFeeAssetBalance</code> the balance in the origin account of the asset that is sent along with the transfer to pay for the fees, if any <code>getFee</code> a function that estimates the fees for depositing a given amount <code>send</code> a function that sends the withdraw transfer data"},{"location":"example-usage/#send-withdraw","title":"Send","text":"<p>When calling <code>send</code>, you will actually send the withdraw transfer data that has been built using the <code>withdraw</code>, <code>to</code>, and <code>get</code> functions. You simply have to pass in a specified amount to send and an optional callback for handling the extrinsic event. For example, entering <code>10000000000n</code> will send <code>1</code> xcDOT on Moonbeam back to DOT on Polkadot.</p> <p>You can refer back to the example in the Withdraw section to see how the <code>send</code> function is used.</p>"},{"location":"example-usage/#get-fee-withdraw","title":"Get Fee","text":"<p>The <code>getFee</code> function estimates the fees for transferring a given amount of the asset specified in the <code>withdraw</code> function. An example of getting the fee in GLMR for transferring xcDOT from Moonbeam back to DOT on Polkadot is as follows:</p> <pre><code>import { AssetSymbol, ChainKey } from '@moonbeam-network/xcm-config';\nimport { init } from '@moonbeam-network/xcm-sdk';\nimport { toDecimal } from '@moonbeam-network/xcm-utils';\n\n// ...\n\nasync function getWithdrawFee() {\n  const dot = AssetSymbol.DOT;\n  const polkadot = ChainKey.Polkadot;\n\n  const { to } = moonbeam.withdraw(dot);\n  const { asset, getFee } = await from(polkadot).get(\n    'INSERT_POLKADOT_ADDRESS',\n    { ethersSigner }, // Only required if you didn't pass the signer in on initialization\n  );\n\n  const fee = await getFee('INSERT_AMOUNT');\n  console.log(\n    `Fee to deposit is estimated to be: ${toDecimal(\n      fee,\n      moonbeam.moonChain.decimals,\n    ).toFixed()} ${moonbeam.moonAsset.originSymbol}`,\n  );\n}\n\ngetWithdrawFee();\n</code></pre>"},{"location":"example-usage/#subscribe","title":"Subscribe to Assets Balance Information","text":"<p>To subscribe to balance information and get a given account's latest balance for each of the supported assets, you can use the <code>subscribeToAssetsBalanceInfo</code> function and pass in the address you want to get the balance for and a callback function to handle the data:</p> MoonbeamMoonriverMoonbase Alpha <pre><code>moonbeam.subscribeToAssetsBalanceInfo('INSERT_ADDRESS', cb);\n</code></pre> <pre><code>moonriver.subscribeToAssetsBalanceInfo('INSERT_ADDRESS', cb);\n</code></pre> <pre><code>moonbase.subscribeToAssetsBalanceInfo('INSERT_ADDRESS', cb);\n</code></pre> <p>The following example retrieves the balance information for a given account on Moonbeam and prints the balance for each of the supported assets to the console:</p> <pre><code>const unsubscribe = await moonbeam.subscribeToAssetsBalanceInfo(\n  'INSERT_MOONBEAM_ADDRESS',\n  (balances) =&gt; {\n    balances.forEach(({ asset, balance, origin }) =&gt; {\n      console.log(\n        `${balance.symbol}: ${toDecimal(\n          balance.balance,\n          balance.decimals,\n        ).toFixed()} (${origin.name} ${asset.originSymbol})`,\n      );\n    });\n  },\n);\n\nunsubscribe();\n</code></pre>"},{"location":"example-usage/#sdk-utils","title":"Utility Functions","text":"<p>There are utility functions in both the XCM SDK and the XCM Utilities packages. The XCM SDK provides the following SDK-related utility functions:</p> <ul> <li><code>isXcmSdkDeposit</code></li> <li><code>isXcmSdkWithdraw</code></li> </ul> <p>And the XCM Utilities package provides the following generic utility functions:</p> <ul> <li><code>toDecimal</code></li> <li><code>toBigInt</code></li> <li><code>hasDecimalOverflow</code></li> </ul>"},{"location":"example-usage/#deposit-check","title":"Check if Transfer Data is for a Deposit","text":"<p>To determine whether transfer data is for a deposit, you can pass in transfer data to the <code>isXcmSdkDeposit</code> function and a boolean will be returned. If <code>true</code> is returned the transfer data is for a deposit, and <code>false</code> is returned if it is not.</p> <p>The following are some examples:</p> <pre><code>import { init, isXcmSdkDeposit } from '@moonbeam-network/xcm-sdk';\n\n...\n\nconst deposit = moonbeam.deposit(moonbeam.symbols[0]);\nconsole.log(isXcmSdkDeposit(deposit)); // Returns true\n</code></pre> <pre><code>import { init, isXcmSdkDeposit } from '@moonbeam-network/xcm-sdk';\n\n...\n\nconst withdraw = moonbeam.withdraw(moonbeam.symbols[0]);\nconsole.log(isXcmSdkDeposit(withdraw)); // Returns false\n</code></pre>"},{"location":"example-usage/#withdraw-check","title":"Check if Transfer Data is for a Withdrawal","text":"<p>To determine whether transfer data is for a withdrawal, you can pass in transfer data to the <code>isXcmSdkWithdraw</code> function and a boolean will be returned. If <code>true</code> is returned the transfer data is for a withdrawal, and <code>false</code> is returned if it is not.</p> <p>The following are some examples:</p> <pre><code>import { init, isXcmSdkWithdraw } from '@moonbeam-network/xcm-sdk';\n\n...\n\nconst withdraw = moonbeam.withdraw(moonbeam.symbols[0]);\nconsole.log(isXcmSdkWithdraw(withdraw)); // Returns true\n</code></pre> <pre><code>import { init, isXcmSdkWithdraw } from '@moonbeam-network/xcm-sdk';\n\n...\n\nconst deposit = moonbeam.deposit(moonbeam.symbols[0]);\nconsole.log(isXcmSdkDeposit(deposit)); // Returns false\n</code></pre>"},{"location":"example-usage/#decimals","title":"Convert Balance to Decimal or BigInt","text":"<p>To convert a balance to decimal format, you can use the <code>toDecimal</code> function, which returns a given number in decimal format based on the number of decimals provided. You can optionally pass in a value for a third argument to dictate the maximum number of decimal places used; otherwise, the default is <code>6</code>; and a fourth argument that dictates the rounding method of the number. The <code>toDecimal</code> function returns a Big number type that you can convert to a number or string using its methods <code>toNumber</code>, <code>toFixed</code>, <code>toPrecision</code>, and <code>toExponential</code>. We recommend using them as a string, since big numbers or numbers with a lot of decimals can lose precision when using number types.</p> <p>To convert from decimal number back to BigInt, you can use the <code>toBigInt</code> function which returns a given number in BigInt format based on the number of decimals provided.</p> <p>For example, to convert a balance on Moonbeam from Wei to Glimmer you can use the following code:</p> <pre><code>import { toDecimal, toBigInt } from '@moonbeam-network/xcm-utils';\n\nconst balance = toDecimal(3999947500000000000n, 18).toFixed();\nconsole.log(balance); // Returns '3.999947'\n\nconst big = toBigInt('3.999947', 18);\nconsole.log(big); // Returns 3999947000000000000n\n</code></pre> <p>You can also use <code>hasDecimalOverflow</code> to make sure that a given number does not have more decimal places than allowed. This is helpful for form inputs.</p>"},{"location":"reference/interfaces/","title":"Moonbeam XCM SDK Reference: Types and Interfaces","text":"<p>The XCM SDK is based on defining an asset to transfer, then the source chain to send the asset from, and the destination chain to send the asset to, which, together, build the transfer data.</p>"},{"location":"reference/interfaces/#core-sdk-interfaces","title":"Core Interfaces","text":"<p>The SDK provides the following core interfaces, which can be accessed after initialization:</p> Interface Description <code>symbols</code> A list containing the asset's origin chain symbol for each of the supported assets for the initialized Moonbeam network <code>assets</code> A list of the supported assets for the initialized Moonbeam network along with their asset ID, precompiled address on Moonbeam, and the asset symbol <code>moonAsset</code> Contains the asset ID, precompile contract address, and native asset symbol for the initialized Moonbeam network <code>moonChain</code> Contains the chain key, name, WSS endpoint, parachain ID, decimals of the native asset, chain ID, and units per second for the initialized Moonbeam network"},{"location":"reference/methods/","title":"Moonbeam XCM SDK Reference: Methods","text":"<p>The SDK provides an API that enables you to get asset information for each supported asset, the source chains where a given asset can be sent from, and, given a source chain, the supported destination chains where the given asset can be sent. The SDK also includes helper methods related to transferring cross-chain assets, such as getting an estimated amount of the asset the destination account will receive, less any execution fees, and asset conversion methods based on the asset and the number of decimals it has. All of these enable you to transfer assets across chains easily and seamlessly.</p>"},{"location":"reference/methods/#core-sdk-methods","title":"Core Methods","text":"<p>The SDK provides the following core methods:</p> Method Description <code>init()</code> Initializes the XCM SDK. Must be called first before any other SDK methods <code>deposit()</code> Initiates a deposit to transfer assets from another chain to Moonbeam <code>withdraw()</code> Initiates a withdraw to transfer assets from Moonbeam to another chain <code>subscribeToAssetsBalanceInfo()</code> Listens for balance changes for a given account for each of the supported assets <code>isXcmSdkDeposit()</code> Returns a boolean indicating whether the given transfer data is for a deposit or not <code>isXcmSdkWithdraw()</code> Returns a boolean indicating whether the given transfer data is for a withdraw or not <code>toDecimal()</code> Returns a given balance in decimal format <code>toBigInt()</code> Returns a given decimal in BigInt format"},{"location":"reference/methods/#deposit-methods","title":"Deposit Methods","text":"<p>When building the transfer data needed for a deposit, you'll use multiple methods to build the underlying XCM message and send it:</p> Method Description <code>deposit()</code> Initiates a deposit to transfer assets from another chain to Moonbeam <code>from()</code> Sets the source chain where the deposit will originate from.  This function is returned from the <code>deposit()</code> function.  Must call <code>deposit()</code> first <code>get()</code> Sets the account on Moonbeam to deposit the funds to and the  source account where the deposit will be sent from.  This function is returned from the <code>from()</code> function.  Must call <code>from()</code> first <code>send()</code> Sends the deposit transfer data given an amount to send.  This function is returned from the <code>get()</code> function.  Must call <code>get()</code> first <code>getFee()</code> Returns an estimate of the fee for transferring a given amount,  which will be paid in the asset specified in the <code>deposit()</code> function.  This function is returned from the <code>get()</code> function.  Must call <code>get()</code> first"},{"location":"reference/methods/#withdraw-methods","title":"Withdraw Methods","text":"<p>When building the transfer data needed for a withdraw, you'll use multiple methods to build the underlying XCM message and send it:</p> Method Description <code>withdraw()</code> Initiates a withdraw to transfer assets from Moonbeam to another chain <code>to()</code> Sets the destination chain where the assets will be withdrawn to.  This function is returned from the <code>withdraw()</code> function.  Must call <code>withdraw()</code> first <code>get()</code> Sets the account on the destination chain to send the withdrawn funds to.  This function is returned from the <code>to()</code> function.  Must call <code>to()</code> first <code>send()</code> Sends the withdraw transfer data given an amount to send.  This function is returned from the <code>get()</code> function.  Must call <code>get()</code> first <code>getFee()</code> Returns an estimate of the fee for transferring a given amount,  which will be paid in the asset specified in the <code>withdraw()</code> function.  This function is returned from the <code>get()</code> function.  Must call <code>get()</code> first"}]}